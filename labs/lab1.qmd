---
title: "Lab 1: Introduction to the Tidyverse"
author: "Your Name Here"
date: today
project: 
  type: website
  execute-dir: project
format:
  html:
    toc: true
    code-fold: false
    embed-resources: true
---

## Setup Instructions

Let's practice using the folder structure you already set up:

1.  Download `lab1.qmd` from bCourse under "labs" \> "Lab #1"
2.  Create a `labs` folder inside your `soc106` folder
3.  Place `lab1.qmd` in the `labs` folder. Your folder structure should now look like this:

```
soc106/
├── _quarto.yml
├── data/
│   └── attain.csv
├── assignments/
│   └── hw0.qmd
└── labs/
    └── lab1.qmd
```

4.  Use the `Explorer` button on the left to find and open `lab1.qmd`

5. Let's work through it together!

------------------------------------------------------------------------

## Load Libraries and Data

First, we need to load the tidyverse and here packages.

```{r}
#| eval: false

# Run these in the console only if not already installed
#install.packages("tidyverse")
#install.packages("here")
```

Load the libraries:

```{r}
#| message: false
#| warning: false

# load libraries
library(tidyverse)
library(here)
```

Now, let's import our data and glimpse it.

```{r}

# Load data
attain <- read_csv(here("data", "attain.csv"))

# Preview the data structure
attain |> glimpse()

```

The `attain` dataset comes from the General Social Survey and contains information about respondents' demographics, education, and family background.

------------------------------------------------------------------------

## Using `select()`

The `select()` function allows you to choose specific columns from a dataframe.

**Syntax:** `select(column1, column2, ...)`

-   List the column names you want to keep, separated by commas
-   Column names don't need quotes
-   The order you list them is the order they'll appear

```{r}
# Select education-related variables
attain |>
  select(educ, paeduc, maeduc) |>
  head(5)
```

**Try it yourself:** Modify the code above to select different columns like `age`, `sex`, `race`, and `marital`.

```{r}
# Your code here

```

------------------------------------------------------------------------

## Using `slice()`

The `slice()` function selects specific rows by their position (row number).

**Syntax:** `slice(row_numbers)`

-   Use a single number for one row: `slice(5)`
-   Use `:` to specify a range: `slice(50:55)` means rows 50 through 55
-   Use `c()` for non-consecutive rows: `slice(c(1, 5, 10))`

```{r}
# Get rows 50 through 55
attain |>
  slice(50:55)
```

**Try it yourself:** Modify the code to get the first 10 rows of the dataset.

```{r}
# Your code here

```

------------------------------------------------------------------------

## Using `filter()`

The `filter()` function selects rows based on conditions.

**Syntax:** `filter(condition)`

-   Use logical operators to create conditions:
    -   `==` equal to (note: two equals signs!)
    -   `!=` not equal to
    -   `>`, `<`, `>=`, `<=` for comparisons
-   For text values, put them in quotes: `filter(marital == "married")`
-   For numbers, no quotes needed: `filter(age > 50)`

### Filtering with numeric variables

```{r}
# Find respondents over age 50
attain |>
  filter(age > 50) |>
  head(5)
```

**Try it yourself:** Find all respondents who are under age 30.

```{r}
# Your code here

```

### Filtering with character variables

You can also filter on character (text) variables using `==`:

```{r}
# Find married respondents
attain |>
  filter(marital == "married") |>
  head(5)
```

**Try it yourself:** Now divorced respondents

```{r}
# Your code here

```

------------------------------------------------------------------------

## Combining Functions

One of the most powerful features of the tidyverse is chaining multiple operations together with the pipe (`|>`):

```{r}
# Find respondents over 40, select key demographics
attain |>
  filter(age > 40) |>
  select(age, sex, educ, marital) |>
  slice(1:6)
```

**Try it yourself:** Chain together functions to find married respondents, select their age and education, and show the first 10 rows.

```{r}
# Your code here

```

------------------------------------------------------------------------

## Using `mutate()`

The `mutate()` function creates new variables based on existing ones.

**Syntax:** `mutate(new_column_name = expression)`

-   Left side of `=` is the name of your new column
-   Right side is the calculation or transformation
-   You can use math operations: `+`, `-`, `*`, `/`
-   You can reference existing columns by name

```{r}
# Create a variable for years of education beyond high school
attain |>
  mutate(college_years = educ - 12) |>
  select(educ, college_years) |>
  head(5)
```

**Try it yourself:** Create a new variable that calculates how many years ago the respondent got married (hint: use `age` and `agewed`).

```{r}
# Your code here

```

------------------------------------------------------------------------

## Using `rename()`

The `rename()` function changes column names.

**Syntax:** `rename(new_name = old_name)`

-   Left side of `=` is the NEW name you want
-   Right side is the OLD name that currently exists
-   Think of it as: "new_name gets old_name"

```{r}
# Rename a column
attain |>
  rename(years_of_education = educ) |>
  select(years_of_education, age) |>
  head(3)
```

**Try it yourself:** Rename the `marital` column to `marital_status`.

```{r}
# Your code here

```

------------------------------------------------------------------------

## Handling Missing Data with `filter()`

Missing values in R are represented as `NA` (Not Available).

**Syntax:**

-   `is.na(column)` — returns `TRUE` if the value is missing
-   `!is.na(column)` — returns `TRUE` if the value is NOT missing (the `!` means "not")
-   Use these inside `filter()` to keep or remove rows with missing data

```{r}
# Count how many have missing father's education data
attain |>
  filter(is.na(paeduc)) |>
  nrow()
```

```{r}
# Keep only respondents with non-missing father's education
attain |>
  filter(!is.na(paeduc)) |>
  glimpse()
```

**Try it yourself:** Count how many respondents have missing data for `agewed` (age at first marriage).

```{r}
# Your code here

```

------------------------------------------------------------------------

## Combining Logical Conditions

You can combine multiple conditions inside `filter()`:

**Syntax:**

-   `&` (and) — both conditions must be true
-   `|` (or) — at least one condition must be true

```{r}
# Find respondents with non-missing data for BOTH educ AND paeduc
attain |>
  filter(!is.na(educ) & !is.na(paeduc)) |>
  select(educ, paeduc) |>
  head(5)
```

You can also use `|` (or) to match any of several conditions:

```{r}
# Find respondents who are either divorced OR widowed
attain |>
  filter(marital == "divorced" | marital == "widowed") |>
  select(age, marital) |>
  head(5)
```

**Try it yourself:** Find respondents who are over 40 AND have more than 12 years of education.

```{r}
# Your code here

```

------------------------------------------------------------------------

## Summary

In this lab, you learned how to use these key tidyverse functions:

| Function               | Purpose                  |
|------------------------|--------------------------|
| `select()`             | Choose columns           |
| `slice()`              | Choose rows by position  |
| `filter()`             | Choose rows by condition |
| `mutate()`             | Create new variables     |
| `rename()`             | Rename columns           |
| `is.na()` / `!is.na()` | Check for missing values |

You also learned how to chain these functions together using the pipe (`|>`) to create readable data manipulation workflows.

------------------------------------------------------------------------
